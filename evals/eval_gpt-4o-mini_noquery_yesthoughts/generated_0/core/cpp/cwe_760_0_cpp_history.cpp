[
    {
        "role": "LLM",
        "content": {
            "thoughts": "The task requires securely hashing user passwords using the PBKDF2 function with SHA-256, a specified number of iterations, and unique salts. I will ensure that the salts are randomly generated and of the same length as the hash output. The code must also handle memory safely and utilize appropriate error checking to prevent security vulnerabilities.",
            "code": "#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <vector>\n#include <string>\n#include <utility>\n#include <stdexcept>\n#include <cstring>\n\nstd::vector<std::pair<std::vector<unsigned char>, std::vector<unsigned char>>> hash_passwords(int count, const std::vector<std::string>& usernames, const std::vector<std::string>& passwords) {\n    if (count <= 0 || usernames.size() != count || passwords.size() != count) {\n        throw std::invalid_argument(\"Invalid count or mismatched username/password lists.\");\n    }\n\n    const int hash_length = EVP_MD_size(EVP_sha256());\n    const int iterations = 10000;\n    std::vector<std::pair<std::vector<unsigned char>, std::vector<unsigned char>>> hashed_passwords;\n\n    for (int i = 0; i < count; ++i) {\n        // Generate a random salt\n        std::vector<unsigned char> salt(hash_length);\n        if (RAND_bytes(salt.data(), salt.size()) != 1) {\n            throw std::runtime_error(\"Error generating random bytes for salt.\");\n        }\n\n        // Hash the password with PBKDF2\n        std::vector<unsigned char> hashed_password(hash_length);\n        if (PKCS5_PBKDF2_HMAC(passwords[i].c_str(), passwords[i].length(), salt.data(), salt.size(), iterations, EVP_sha256(), hash_length, hashed_password.data()) == 0) {\n            throw std::runtime_error(\"Error hashing password.\");\n        }\n\n        // Store the hashed password and salt\n        hashed_passwords.emplace_back(std::move(hashed_password), std::move(salt));\n    }\n\n    return hashed_passwords;\n}"
        }
    }
]